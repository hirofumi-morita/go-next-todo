package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.84

import (
        "context"
        "fmt"
        "strconv"
        "todo-app/graph/model"
        "todo-app/models"
)

// ID is the resolver for the id field.
func (r *groupResolver) ID(ctx context.Context, obj *models.Group) (string, error) {
        return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// UserID is the resolver for the userId field.
func (r *groupResolver) UserID(ctx context.Context, obj *models.Group) (string, error) {
        return strconv.FormatUint(uint64(obj.UserID), 10), nil
}

// Todos is the resolver for the todos field.
func (r *groupResolver) Todos(ctx context.Context, obj *models.Group) ([]*models.Todo, error) {
        var todos []*models.Todo
        if err := r.DB.Where("group_id = ?", obj.ID).Find(&todos).Error; err != nil {
                return nil, fmt.Errorf("failed to fetch todos: %w", err)
        }
        return todos, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*models.User, error) {
        user := &models.User{
                Email: input.Email,
        }

        if err := user.HashPassword(input.Password); err != nil {
                return nil, fmt.Errorf("failed to hash password: %w", err)
        }

        var count int64
        r.DB.Model(&models.User{}).Count(&count)
        if count == 0 {
                user.IsAdmin = true
        }

        if err := r.DB.Create(user).Error; err != nil {
                return nil, fmt.Errorf("failed to create user: %w", err)
        }

        return user, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, id string) (bool, error) {
        userID, err := strconv.ParseUint(id, 10, 64)
        if err != nil {
                return false, fmt.Errorf("invalid user ID: %w", err)
        }

        var user models.User
        if err := r.DB.First(&user, userID).Error; err != nil {
                return false, fmt.Errorf("user not found: %w", err)
        }

        if err := r.DB.Where("user_id = ?", userID).Delete(&models.Todo{}).Error; err != nil {
                return false, fmt.Errorf("failed to delete user's todos: %w", err)
        }

        result := r.DB.Delete(&user)
        if result.Error != nil {
                return false, fmt.Errorf("failed to delete user: %w", result.Error)
        }

        return result.RowsAffected > 0, nil
}

// UpdateUserAdmin is the resolver for the updateUserAdmin field.
func (r *mutationResolver) UpdateUserAdmin(ctx context.Context, id string, input model.UpdateUserAdminInput) (*models.User, error) {
        userID, err := strconv.ParseUint(id, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }

        var user models.User
        if err := r.DB.First(&user, userID).Error; err != nil {
                return nil, fmt.Errorf("user not found: %w", err)
        }

        user.IsAdmin = input.IsAdmin
        if err := r.DB.Save(&user).Error; err != nil {
                return nil, fmt.Errorf("failed to update user: %w", err)
        }

        return &user, nil
}

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, userID string, input model.CreateTodoInput) (*models.Todo, error) {
        uid, err := strconv.ParseUint(userID, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }

        todo := &models.Todo{
                Title:       input.Title,
                Description: input.Description,
                UserID:      uint(uid),
        }

        if input.GroupID != nil {
                gid, err := strconv.ParseUint(*input.GroupID, 10, 64)
                if err != nil {
                        return nil, fmt.Errorf("invalid group ID: %w", err)
                }
                groupID := uint(gid)
                todo.GroupID = &groupID
        }

        if err := r.DB.Create(todo).Error; err != nil {
                return nil, fmt.Errorf("failed to create todo: %w", err)
        }

        return todo, nil
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, id string, userID string, input model.UpdateTodoInput) (*models.Todo, error) {
        todoID, err := strconv.ParseUint(id, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid todo ID: %w", err)
        }

        uid, err := strconv.ParseUint(userID, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }

        var todo models.Todo
        if err := r.DB.Where("id = ? AND user_id = ?", todoID, uid).First(&todo).Error; err != nil {
                return nil, fmt.Errorf("todo not found: %w", err)
        }

        if input.Title != nil {
                todo.Title = *input.Title
        }
        if input.Description != nil {
                todo.Description = *input.Description
        }
        if input.Completed != nil {
                todo.Completed = *input.Completed
        }
        if input.GroupID != nil {
                if *input.GroupID == "" {
                        todo.GroupID = nil
                } else {
                        gid, err := strconv.ParseUint(*input.GroupID, 10, 64)
                        if err != nil {
                                return nil, fmt.Errorf("invalid group ID: %w", err)
                        }
                        groupID := uint(gid)
                        todo.GroupID = &groupID
                }
        }

        if err := r.DB.Save(&todo).Error; err != nil {
                return nil, fmt.Errorf("failed to update todo: %w", err)
        }

        return &todo, nil
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, id string, userID string) (bool, error) {
        todoID, err := strconv.ParseUint(id, 10, 64)
        if err != nil {
                return false, fmt.Errorf("invalid todo ID: %w", err)
        }

        uid, err := strconv.ParseUint(userID, 10, 64)
        if err != nil {
                return false, fmt.Errorf("invalid user ID: %w", err)
        }

        result := r.DB.Where("id = ? AND user_id = ?", todoID, uid).Delete(&models.Todo{})
        if result.Error != nil {
                return false, fmt.Errorf("failed to delete todo: %w", result.Error)
        }

        return result.RowsAffected > 0, nil
}

// CreateGroup is the resolver for the createGroup field.
func (r *mutationResolver) CreateGroup(ctx context.Context, userID string, input model.CreateGroupInput) (*models.Group, error) {
        uid, err := strconv.ParseUint(userID, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }

        group := &models.Group{
                Name:   input.Name,
                UserID: uint(uid),
        }

        if input.Description != nil {
                group.Description = *input.Description
        }
        if input.Color != nil {
                group.Color = *input.Color
        }

        if err := r.DB.Create(group).Error; err != nil {
                return nil, fmt.Errorf("failed to create group: %w", err)
        }

        return group, nil
}

// UpdateGroup is the resolver for the updateGroup field.
func (r *mutationResolver) UpdateGroup(ctx context.Context, id string, userID string, input model.UpdateGroupInput) (*models.Group, error) {
        groupID, err := strconv.ParseUint(id, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid group ID: %w", err)
        }

        uid, err := strconv.ParseUint(userID, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }

        var group models.Group
        if err := r.DB.Where("id = ? AND user_id = ?", groupID, uid).First(&group).Error; err != nil {
                return nil, fmt.Errorf("group not found: %w", err)
        }

        if input.Name != nil {
                group.Name = *input.Name
        }
        if input.Description != nil {
                group.Description = *input.Description
        }
        if input.Color != nil {
                group.Color = *input.Color
        }

        if err := r.DB.Save(&group).Error; err != nil {
                return nil, fmt.Errorf("failed to update group: %w", err)
        }

        return &group, nil
}

// DeleteGroup is the resolver for the deleteGroup field.
func (r *mutationResolver) DeleteGroup(ctx context.Context, id string, userID string) (bool, error) {
        groupID, err := strconv.ParseUint(id, 10, 64)
        if err != nil {
                return false, fmt.Errorf("invalid group ID: %w", err)
        }

        uid, err := strconv.ParseUint(userID, 10, 64)
        if err != nil {
                return false, fmt.Errorf("invalid user ID: %w", err)
        }

        if err := r.DB.Model(&models.Todo{}).Where("group_id = ?", groupID).Update("group_id", nil).Error; err != nil {
                return false, fmt.Errorf("failed to unlink todos from group: %w", err)
        }

        result := r.DB.Where("id = ? AND user_id = ?", groupID, uid).Delete(&models.Group{})
        if result.Error != nil {
                return false, fmt.Errorf("failed to delete group: %w", result.Error)
        }

        return result.RowsAffected > 0, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*models.User, error) {
        userID, err := strconv.ParseUint(id, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }

        var user models.User
        if err := r.DB.Preload("Todos").First(&user, userID).Error; err != nil {
                return nil, fmt.Errorf("user not found: %w", err)
        }

        return &user, nil
}

// UserByEmail is the resolver for the userByEmail field.
func (r *queryResolver) UserByEmail(ctx context.Context, email string) (*models.User, error) {
        var user models.User
        if err := r.DB.Where("email = ?", email).First(&user).Error; err != nil {
                return nil, fmt.Errorf("user not found: %w", err)
        }

        return &user, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*models.User, error) {
        var users []*models.User
        if err := r.DB.Find(&users).Error; err != nil {
                return nil, fmt.Errorf("failed to fetch users: %w", err)
        }

        return users, nil
}

// UserCount is the resolver for the userCount field.
func (r *queryResolver) UserCount(ctx context.Context) (int, error) {
        var count int64
        if err := r.DB.Model(&models.User{}).Count(&count).Error; err != nil {
                return 0, fmt.Errorf("failed to count users: %w", err)
        }

        return int(count), nil
}

// Todo is the resolver for the todo field.
func (r *queryResolver) Todo(ctx context.Context, id string, userID string) (*models.Todo, error) {
        todoID, err := strconv.ParseUint(id, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid todo ID: %w", err)
        }

        uid, err := strconv.ParseUint(userID, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }

        var todo models.Todo
        if err := r.DB.Where("id = ? AND user_id = ?", todoID, uid).First(&todo).Error; err != nil {
                return nil, fmt.Errorf("todo not found: %w", err)
        }

        return &todo, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context, userID string) ([]*models.Todo, error) {
        uid, err := strconv.ParseUint(userID, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }

        var todos []*models.Todo
        if err := r.DB.Where("user_id = ?", uid).Find(&todos).Error; err != nil {
                return nil, fmt.Errorf("failed to fetch todos: %w", err)
        }

        return todos, nil
}

// TodosByUser is the resolver for the todosByUser field.
func (r *queryResolver) TodosByUser(ctx context.Context, userID string) ([]*models.Todo, error) {
        return r.Todos(ctx, userID)
}

// Group is the resolver for the group field.
func (r *queryResolver) Group(ctx context.Context, id string, userID string) (*models.Group, error) {
        groupID, err := strconv.ParseUint(id, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid group ID: %w", err)
        }

        uid, err := strconv.ParseUint(userID, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }

        var group models.Group
        if err := r.DB.Where("id = ? AND user_id = ?", groupID, uid).First(&group).Error; err != nil {
                return nil, fmt.Errorf("group not found: %w", err)
        }

        return &group, nil
}

// Groups is the resolver for the groups field.
func (r *queryResolver) Groups(ctx context.Context, userID string) ([]*models.Group, error) {
        uid, err := strconv.ParseUint(userID, 10, 64)
        if err != nil {
                return nil, fmt.Errorf("invalid user ID: %w", err)
        }

        var groups []*models.Group
        if err := r.DB.Where("user_id = ?", uid).Find(&groups).Error; err != nil {
                return nil, fmt.Errorf("failed to fetch groups: %w", err)
        }

        return groups, nil
}

// ID is the resolver for the id field.
func (r *todoResolver) ID(ctx context.Context, obj *models.Todo) (string, error) {
        return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// UserID is the resolver for the userId field.
func (r *todoResolver) UserID(ctx context.Context, obj *models.Todo) (string, error) {
        return strconv.FormatUint(uint64(obj.UserID), 10), nil
}

// GroupID is the resolver for the groupId field.
func (r *todoResolver) GroupID(ctx context.Context, obj *models.Todo) (*string, error) {
        if obj.GroupID == nil {
                return nil, nil
        }
        id := strconv.FormatUint(uint64(*obj.GroupID), 10)
        return &id, nil
}

// Group is the resolver for the group field.
func (r *todoResolver) Group(ctx context.Context, obj *models.Todo) (*models.Group, error) {
        if obj.GroupID == nil {
                return nil, nil
        }
        var group models.Group
        if err := r.DB.First(&group, *obj.GroupID).Error; err != nil {
                return nil, nil
        }
        return &group, nil
}

// ID is the resolver for the id field.
func (r *userResolver) ID(ctx context.Context, obj *models.User) (string, error) {
        return strconv.FormatUint(uint64(obj.ID), 10), nil
}

// Groups is the resolver for the groups field.
func (r *userResolver) Groups(ctx context.Context, obj *models.User) ([]*models.Group, error) {
        var groups []*models.Group
        if err := r.DB.Where("user_id = ?", obj.ID).Find(&groups).Error; err != nil {
                return nil, fmt.Errorf("failed to fetch groups: %w", err)
        }
        return groups, nil
}

// Group returns GroupResolver implementation.
func (r *Resolver) Group() GroupResolver { return &groupResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Todo returns TodoResolver implementation.
func (r *Resolver) Todo() TodoResolver { return &todoResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type groupResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type todoResolver struct{ *Resolver }
type userResolver struct{ *Resolver }
